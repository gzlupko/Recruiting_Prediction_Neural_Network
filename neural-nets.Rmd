---
title: "Neural Networks"
author: "Gian Zlupko"
date: "1/28/2018"
output: html_document
---

## Part I - Introduction to Using Neural Nets

In the attached data sets attention1.csv and attention2.csv, you will find data that describe features associated with webcam images of 100 students' faces as they particpate in an online discussion. The variables are:

eyes - student has their eyes open (1 = yes, 0 = no)
face.forward - student is facing the camera (1 = yes, 0 = no)
chin.up - student's chin is raised above 45 degrees (1 = yes, 0 = no)
squint - eyes are squinting
hunch - shoulders are hunched over
mouth1 - mouth is smiling
mouth2 - mouth is frowning
mouth3 - mouth is open
attention - whether the student was paying attention when asked (1 = yes, 0 = no)

We will use the webcam data to build a neural net to predict whether or not a student is attending.

First load the neuralnet package and other libraries used 
```{r}

library(neuralnet)
library(readr) 
library(dplyr) 

```

Upload data
```{r}
D1 <- read_csv("attention1.csv") 
  
D2 <- read_csv("attention2.csv") 
```

Now you can build a neural net that predicts attention based on webcam images. The command "neuralnet" sets up the model. It is composed of four basic arguments:

- A formula that describes the inputs and outputs of the neural net (attention is our output)
- The data frame that the model will use
- How many nodes are in the hidden layer
- A threshold that tells the model when to stop adjusting weights to find a better fit. If error does not change more than the threshold from one iteration to the next, the algorithm will stop (We will use 0.01, so if prediction error does not change by more than 1% from one iteration to the next the algorithm will halt)

```{r}
nn <- neuralnet(attention == 1 ~ eyes + face.forward + chin.up + squint + hunch + mouth1 + mouth2 + mouth3, D1, hidden = c(2,2), learningrate = 0.2)

plot(nn)


#The option "hidden" allows you to change the number of hiddden layers and number of nodes within the hidden layers c(1,1) = one hidden layer with 1 node, 0 = zero hidden layers, etc

#The option "learningrate" alters the size of the steps the model takes every time it adjusts the weights.

#Change the hidden layers and learningrate options and check both the prediction and accuracy


```



Create test set, confusion matrix, and analyze prediction accuracy 

```{r}

# create test set 
head(D2) 
test_set <- subset(D2, select = c("attention", "eyes", "face.forward", "chin.up", "squint", "hunch", "mouth1", "mouth2", "mouth3"))

# accuracy 

results <- data.frame(actual = test_set$attention, prediction = nn$net.result)  


```



You have now trained a neural network! The plot shows you the layers of your newtork as black nodes and edges with the calculated weights on each edge. The blue nodes and edges are the bias/threshold terms - it is a little bit confusing that they are represented as nodes, they are not nodes in the sense that the black nodes are. The bias anchors the activation function, the weights change the shape of the activation function while the bias term changes the overall position of the activation function - if you have used linear regression the bias term is like the intercept of the regression equation, it shifts the trend line up and down the y axis, while the other parameters change the angle of the line. The plot also reports the final error rate and the number of iterations ("steps") that it took to reach these weights.

What happens if you increase the number of hidden layers in the neural net? Build a second neural net with more or fewer layers in it and determine if this improves your predictions or not? How can you tell if your new neural network is doing a better job than your first?

Now use your preferred neural net to predict the second data set. You will need to create a new data frame (D3) that only includes the input layers to use this command.

```{r}
D3 <- subset(D2, select = c("eyes", "face.forward", "chin.up", "squint", "hunch", "mouth1", "mouth2", "mouth3"))
```

Now you can create predictions using your neural net
```{r}
#The code below will use your model to predict the outcome using D3 data
pred <- predict(nn, D3)

#The code below will tell you how accurate your model is at predicting the unseen data
table(D2$attention == 1, pred[, 1] > 0.5)

#Adjust both the hidden layer and learning rate and see if that has an impact on error, steps and prediction accuracy


nn2 <- neuralnet(attention == 1 ~ eyes + face.forward + chin.up + squint + hunch + mouth1 + mouth2 + mouth3, D1, hidden = c(4,2), learningrate = 0.1)


nn3 <- neuralnet(attention == 1 ~ eyes + face.forward + chin.up + squint + hunch + mouth1 + mouth2 + mouth3, D1, hidden = c(1,1), learningrate = 0.5)


# create custom function to calculate model accuracy based on confusion matrix 


mod_acc <- function(model) { 
  
pred <- predict(model, D3) 
x <- table(D2$attention == 1, pred[, 1] > 0.5)
true_neg <- x[1,1] 
true_pos <- x[2,2] 
false_pos <- x[1,2]
false_neg <- x[2,1]
correct <- (true_neg + true_pos) / (true_neg + true_pos + false_pos + false_neg)
correct

  }


mod_acc(nn) 
mod_acc(nn2) 
mod_acc(nn3) 

# create list object to store model accuracies for comparison 

fits <- list() 

fits$nn <- mod_acc(nn) 
fits$nn2 <- mod_acc(nn2) 
fits$nn3 <- mod_acc(nn3) 
fits



```

## Please answer the following questions:

1. How accurate is your neural net? How can you tell?

The three neural network algorithms that I created - nn, nn2, and nn3 - are 97%, 98% and 90% accurate, respectively. The accuracy of the model was calculated from the confusion matrix. Specifically, the accuracy refers to the sum of the true positive and true negatives that the model predicted divided by the total number of predictions that the model made. 

2. How would you explain your model to the students whose behavior you are predicting? 

I would explain that this model is able to predict whether the student is paying attention based on 8 factors (e.g. eyes, mouth smiling, frowning, etc). 

3. This is a very simple example of a neural network. Real facial recognition is very complex though. Would a neural network be a good solution for predicting real facial movements? Why, why not? 





## Repeat with your own data

Either synthesize a data set or find a data set online and build a neural net to predict a binary outcome from several inputs. Split your data into two sets and use one set to train the neural net and the other set to make predictions. Change the hidden layers and learning rate until you get the most accurate model you can.



```{r}


library(peopleanalyticsdata) 

data(recruiting) 

head(recruiting) 

recruiting[recruiting == "F"] <- 1 
recruiting[recruiting == "M"] <- 2 

summary(recruiting$gpa) 
sapply(recruiting, summary) 


# data normalization ('feature scaling')

normalize <- function(x) {
  
return ((x - min(x)) / (max(x) - min(x))) 
  
  } 

recruiting_numeric <- as.data.frame(lapply(recruiting, as.numeric)) 
recruiting_norm <- as.data.frame(lapply(recruiting_numeric, normalize)) 



# data split 

N <- (length(recruiting_norm$hired)/2)  

train_size <- floor(nrow(recruiting_norm)*0.5) 
test_size <- (nrow(recruiting_norm) - train_size) 


set.seed(777)

selected <- sample(seq_len(nrow(recruiting_norm)),size = train_size)
training_set <- recruiting_norm[selected, ]
test_set <- recruiting_norm[-selected, ]

nrow(training_set) 
nrow(test_set) 


head(training_set) 
head(test_set) 


# hiring predictions with neural networks 

hiring_mod_1 <- neuralnet(hired == 1 ~ sat + gpa + apttest + int1, training_set, hidden = c(2,2), learningrate = 0.2)




train <- subset(training_set, select = c("gpa","gender", "apttest", "int1", "int2", "int3", "sat")) 

#The code below will use your model to predict the outcome using D3 data


pred <- predict(hiring_mod_1, train)

table(test_set$hired == 1, pred[, 1] > 0.5)

hiring_mod_accuracy <- function(mod) { 
  
pred <- predict(mod, train)
x <- table(test_set$hired == 1, pred[, 1] > 0.5)
true_neg <- x[1,1] 
true_pos <- x[2,2] 
false_pos <- x[1,2]
false_neg <- x[2,1]
correct <- (true_neg + true_pos) / (true_neg + true_pos + false_pos + false_neg)
correct
  
}

hiring_mod_accuracy(hiring_mod_1) 


```

In the following code chunks I add inputs and layers to the nn model sequentially. I also adjust the model learning rate to optimize performance in prediction


```{r}

# add hidden layer to neural netowrk: subsequent interviews 

hiring_mod_2 <- neuralnet(hired == 1 ~ sat + gpa + apttest + int1 + int2 + int3, training_set, hidden = c(2,2), learningrate = 0.2)


hiring_mod_2
pred_mod_2 <- predict(hiring_mod_2, train)
table(test_set$hired == 1, pred_mod_2[, 1] > 0.5)




# calculate nn model accuracy 
hiring_mod_accuracy(hiring_mod_2) 


```

Add gender  

```{r}

hiring_mod_3 <- neuralnet(hired == 1 ~ sat + gpa + apttest + int1 + int2 + int3 ,training_set, hidden = c(3,2), learningrate = 0.2)

# calculate nn model accuracy 
hiring_mod_accuracy(hiring_mod_3, test_set) 


predict(hiring_mod_3, test_set) 
x <- table(df$hired == 1, hiring_pred[ , 1] > 0.5)

?predict
```


Compare with logistic regression


```{r}


log_mod_1 <- glm(hired ~ sat + gpa + apttest + int1 + int2 + int3 , data = training_set, family = "binomial")


```





